from parser import CELL_KINDS, Layout, Cell, LayoutGenome
from nbt_manager import NBTGenerator
from concurrent.futures import ProcessPoolExecutor
from multiprocessing import cpu_count
from typing import List, Tuple, Optional
import psutil
import numpy as np
from tqdm import tqdm
import os
import pickle
import threading
import time
import random
import json
import sys
from dataclasses import dataclass


@dataclass
class GeneticConfig:
    """Configuration parameters for genetic algorithm"""
    population_size: int
    cull_upper_percent: float = 0.1
    cull_random_percent: float = 0.1
    cull_bottom_percent: float = 0.01
    mutation_rate: float = 0.1

class GeneticHandler:
    def __init__(
        self,
        json_data: dict,
        size: int,
        config: Optional[GeneticConfig] = None,
        random_seed: bool = True,
        seed: int = 420
    ):
        """Initialize the genetic handler with configuration"""
        self.seed = None if random_seed else seed
        self.size = size
        self.config = config or GeneticConfig(population_size=size)
        self.epocs = 0
        self.population = self._initialize_population(json_data)
        self.fitness: List[Optional[float]] = [None for _ in range(size)]

    def _initialize_population(self, json_data: dict) -> List[LayoutGenome]:
        """Initialize the starting population"""
        population = []
        for _ in range(self.size):
            layout = Layout(cells={}, ports={}, seed=self.seed)
            layout.parse_json(json_data)
            layout.generate_start_layout()
            population.append(layout.to_genome(seed=self.seed))
        return population

    def run_epoc(self, save: bool = False) -> None:
        """Run a single epoch of the genetic algorithm"""
        self.epocs += 1
        self.evaluate(save=save)
        self.cull()
        self.crossbreed()
        self.mutate()

    @staticmethod
    def _evaluate_gene(gene: LayoutGenome) -> float:
        """
        Evaluate a single gene and return its fitness

        Args:
            gene: The genome to evaluate

        Returns:
            fitness_score: The computed fitness score
        """
        # Set process affinity to distribute load
        pid = os.getpid()
        try:
            process = psutil.Process(pid)
            process.cpu_affinity([pid % cpu_count()])
        except Exception:
            print("not supported psutil")
            pass  # Affinity setting not supported on all platforms

        return gene.compute_fitness()

    def evaluate(self, save: bool = False) -> None:
        """
        Evaluate and sort population by fitness using multiple processes

        Args:
            save: Whether to save checkpoint after evaluation
        """
        # Calculate optimal chunk size for better performance
        chunk_size = max(1, len(self.population) // (cpu_count() * 4))

        # Get the maximum number of workers
        max_workers = cpu_count()
        print(f"Evaluating using {max_workers} CPU cores")

        # Create batches for processing
        population_batches = np.array_split(self.population,
                                          max(1, len(self.population) // chunk_size))

        results = []
        with tqdm(total=len(self.population), desc="Evaluating genes") as progress:
            with ProcessPoolExecutor(max_workers=max_workers) as executor:
                # Process each batch
                for batch in population_batches:
                    # Submit batch of genes for evaluation
                    future_results = list(executor.map(
                        self._evaluate_gene,
                        batch,
                        chunksize=chunk_size
                    ))
                    results.extend(future_results)
                    progress.update(len(batch))

        # Combine results with population for sorting
        population_with_fitness = list(zip(results, self.population))

        # Sort by fitness (descending)
        population_with_fitness.sort(key=lambda x: -x[0])

        # Update population and fitness
        self.fitness, self.population = zip(*population_with_fitness)
        self.fitness = list(self.fitness)
        self.population = list(self.population)

        # Print statistics
        self._print_evaluation_stats()

        if save:
            self._save_checkpoint()

    def _print_evaluation_stats(self) -> None:
        """Print statistical information about the evaluation"""
        fitness_array = np.array(self.fitness)
        stats = {
            "Best Fitness": np.max(fitness_array),
            "Worst Fitness": np.min(fitness_array),
            "Mean Fitness": np.mean(fitness_array),
            "Median Fitness": np.median(fitness_array),
            "Std Dev": np.std(fitness_array)
        }

        print("\nEvaluation Statistics:")
        print("=" * 50)
        for key, value in stats.items():
            print(f"{key:15}: {value:10.4f}")
        print("=" * 50)

    def cull(self) -> None:
        """Cull the population based on configured percentages"""
        config = self.config
        upper_count = int(len(self.population) * config.cull_upper_percent)
        random_count = int(len(self.population) * config.cull_random_percent)
        bottom_count = int(len(self.population) * config.cull_bottom_percent)

        # Select survivors
        upper = self.population[:upper_count] if upper_count > 0 else []
        bottom = self.population[-bottom_count:] if bottom_count > 0 else []
        random_selection = (random.sample(self.population, random_count)
                          if random_count > 0 else [])

        # Combine and shuffle survivors
        result = upper + random_selection + bottom
        random.shuffle(result)

        self.population = result
        self.fitness = [None for _ in range(len(result))]

    def mutate(self) -> None:
        """Apply mutations to the population"""
        for idx, gene in enumerate(self.population):
            gene.mutate_movement()
            gene.mutate_rand_pos()
            self.population[idx] = gene

    def crossbreed(self, target_size: Optional[int] = None) -> None:
        """Perform crossbreeding to reach target population size"""
        target_size = target_size or self.size

        while len(self.population) < target_size:
            parents = random.sample(self.population, 2)
            child = LayoutGenome.crossbreed(*parents)
            self.population.append(child)

        self.fitness = [None for _ in range(self.size)]

    def save(self, filepath: str) -> None:
        """Save handler state to file"""
        with open(filepath, "wb") as f:
            pickle.dump(self, f, protocol=pickle.HIGHEST_PROTOCOL)
        print(f"GeneticHandler saved to {filepath}")

    @classmethod
    def load(cls, filepath: str) -> 'GeneticHandler':
        """Load handler state from file"""
        with open(filepath, "rb") as f:
            instance = pickle.load(f)
        print(f"GeneticHandler loaded from {filepath}")
        return instance

    def _save_checkpoint(self) -> None:
        """Save current state to checkpoint file with performance optimizations"""
        filename = f"GeneticHandler_{str(self.seed)}_{self.size}_{self.epocs}.pkl"

        # Use a temporary file to prevent corruption on crash
        temp_filename = filename + ".tmp"
        try:
            with open(temp_filename, "wb") as f:
                pickle.dump(self, f, protocol=pickle.HIGHEST_PROTOCOL)
            os.replace(temp_filename, filename)
            print(f"Checkpoint saved: {filename}")
        except Exception as e:
            print(f"Error saving checkpoint: {e}")
            if os.path.exists(temp_filename):
                os.remove(temp_filename)

def monitor_performance():
    """Monitor CPU and memory usage"""
    while True:
        cpu_percent = psutil.cpu_percent(interval=1)
        memory = psutil.virtual_memory()
        print(f"\rCPU Usage: {cpu_percent}% | Memory Usage: {memory.percent}%",
              end="", flush=True)
        time.sleep(1)

def main():
    """Main entry point for genetic algorithm"""
    LOAD_FROM_CHECKPOINT = False

    # Start performance monitoring in a separate thread
    if not LOAD_FROM_CHECKPOINT:
        monitor_thread = threading.Thread(target=monitor_performance, daemon=True)
        monitor_thread.start()

    if LOAD_FROM_CHECKPOINT:
        handler = GeneticHandler.load("GeneticHandler.pkl")
        for fitness in handler.fitness:
            print(f"{fitness}")
        return

    # Load input data
    json_file = "../synth.json"
    try:
        with open(json_file, 'r') as f:
            json_data = json.load(f)
    except FileNotFoundError:
        print(f"Error: File not found at '{json_file}'")
        sys.exit(1)
    except json.JSONDecodeError:
        print(f"Error: Invalid JSON format in '{json_file}'")
        sys.exit(1)

    # Initialize and run genetic algorithm
    config = GeneticConfig(
        population_size=max(100, cpu_count() * 10)  # Scale with CPU count
    )

    print(f"\nInitializing genetic algorithm with population size: {config.population_size}")
    handler = GeneticHandler(json_data, config.population_size, config=config)

    # Evaluate using all available CPU cores
    handler.evaluate(save=True)


if __name__ == '__main__':
    main()
from parser import CELL_KINDS, Layout, Cell
from nbt_manager import NBTGenerator
import argparse
import json
import sys
import os

def main():
    parser = argparse.ArgumentParser(description="Minecraft Yosys layout generator")
    parser.add_argument("pkl_file", help="Path to the Yosys JSON file")
    args = parser.parse_args()
    layout = Layout.deserialize_layout(args.pkl_file);
    layout.generate();
    nbt_gen = NBTGenerator(layout);
    nbt_gen.generate_file(args.pkl_file+"_layout.nbt")


if __name__ ==  '__main__':
    main()
from parser import CELL_KINDS, Layout, Cell
from nbt_manager import NBTGenerator
import json
import argparse
import os
import sys

def main():
    parser = argparse.ArgumentParser(description="Minecraft Yosys layout generator")
    parser.add_argument("json_file", help="Path to the Yosys JSON file")
    args = parser.parse_args()
    json_data = None
    try:
        with open(args.json_file, 'r') as f:
            json_data = json.load(f)
    except FileNotFoundError:
        print(f"Error: File not found at '{args.json_file}'")
        sys.exit(1);
    except json.JSONDecodeError:
        print(f"Error: Invalid JSON format in '{args.json_file}'")
        sys.exit(1)

    layout = Layout(cells={},ports={})
    layout.parse_json(json_data)
    layout.generate_start_layout();
    nbt_gen = NBTGenerator(layout);
    nbt_gen.generate_file(args.json_file+"_layout.nbt")
    layout.generate_paths();
    nbt_gen = NBTGenerator(layout);
    nbt_gen.generate_file(args.json_file+"_layout.nbt")
    population = []
    for n in range(10):
        population.append(layout.to_genome(seed=n))

    base_fitness = population[0].compute_fitness()
    for n in range(100):
        for idx, gene in enumerate(population):
            gene.mutate_movement();
            gene.mutate_rand_pos();
            population[idx] = gene
    max_fitness = base_fitness
    max_fgene = population[0]
    fitness_list = []
    for idx, gene in enumerate(population):
        fitness = gene.compute_fitness();
        if(max_fitness < fitness):
            max_fgene = gene
            max_fitness = fitness
        fitness_list.append(fitness)


    print(f" base fitness: {base_fitness}")
    for idx, fitness in enumerate(fitness_list):
        print(f"Pop {str(idx)} fitness: {fitness}")

    print(f" Best fitness: {max_fitness}")

    nbt_gen = NBTGenerator(max_fgene.to_layout());
    nbt_gen.generate_file(args.json_file+"_layout_most_fit.nbt")



if __name__ ==  '__main__':
    main()
from typing import List, Tuple, Optional
import nbtlib
from nbtlib import Compound, File
from nbtlib.tag import Int, IntArray, List

from parser import Layout, Cell, CELL_KINDS
import sys

## TODO @(dleiferives,db9ba75f-58a1-47f4-a517-143152e5dae4): Add cell placement
## stuff/ layout design or smnthn ~#

class NBTGenerator:
    def __init__(self, layout: Layout):
        self.layout = layout

    def generate_file(self,filename:str, layout=None):
        if(layout == None):
            layout = self.layout
        if(layout == None):
            print("No layout to generate")
            return


        """
        Exports the current 3D state (cells and wire routes) as an NBT schematic
        using the following structure:

        version: 1
        size: [width, height, length]  (in schematic coordinates)
        pallet: list of compounds, each with a "Name" (e.g. {"Name": "minecraft:air"})
        blocks: list of compounds; each compound defines:
                - pos: [x, y, z] position, in schematic coordinates
                - state: an integer index referencing the block in the pallet

        Voxel assignment (in simulation coordinates):
        - Voxels with a routed wire are "minecraft:red_wool"
        - Voxels occupied by a cell (if not overwritten by a wire) are
                "minecraft:white_wool"
        - All other voxels are "minecraft:air"

        In this simulation we use (x, y, z) with z as up.
        For the schematic we remap:
                schematic X = sim_x - min_x
                schematic Y = sim_z - min_z   (vertical)
                schematic Z = sim_y - min_y
        """

        width  = layout.volume[0]
        length = layout.volume[1]
        height = layout.volume[2]

        grid = [
                [
                ["minecraft:air" for _ in range(length)]
                for _ in range(height)
                ]
                for _ in range(width)
        ]

        cells = layout.generated_cells;
        # Mark cell volumes as white wool.

        wires = layout.gen_wires
        for wire in wires:
            for step in wire:
                tx = step[0]
                ty = step[1]
                tz = step[2]
                grid[tx][ty][tz] = "minecraft:redstone_wire"
                grid[tx][ty][tz-1] = "minecraft:red_wool"

        for cell in cells:
                c_x = cell.pos[0]
                c_y = cell.pos[1]
                c_z = cell.pos[2]
                c_width = cell.pos[3]
                c_depth = cell.pos[4]
                c_height = cell.pos[5]
                for dx in range(c_width):
                        for dy in range(c_depth):
                                for dz in range(c_height):
                                        sim_x = c_x + dx
                                        sim_y = c_y + dy
                                        sim_z = c_z + dz
                                        grid[sim_x][sim_y][sim_z] = "minecraft:white_wool"

        # # Mark wire route voxels as red wool (overriding any cell fill).
        # for route in routes:
        #         for (x, y, z) in route:
        #                 sx = x - grid_min_x
        #                 sy = z - grid_min_z  # simulation z becomes schematic Y
        #                 sz = y - grid_min_y  # simulation y becomes schematic Z
        #                 grid[sx][sy][sz] = "minecraft:red_wool"

        # Define a static palette mapping.
        # The palette maps block name -> index.
        palette_mapping = {
                "minecraft:air": 0,
                "minecraft:white_wool": 1,
                "minecraft:red_wool": 2,
                "minecraft:redstone_wire": 3
        }

        # Build block compounds.
        blocks = []
        # Iterate over every voxel in the 3D schematic grid. The index order here
        # will be used explicitly as the block's pos.
        for sx in range(width):
                for sy in range(height):
                        for sz in range(length):
                                block_type = grid[sx][sy][sz]
                                state_index = palette_mapping[block_type]
                                block_compound = Compound({
                                "pos": nbtlib.tag.List([
                                        nbtlib.tag.Int(sx),
                                        nbtlib.tag.Int(sz),
                                        nbtlib.tag.Int(sy)
                                ]),
                                "state": nbtlib.tag.Int(state_index)
                                })
                                blocks.append(block_compound)
## TODO @(dleiferives,6095c635-a651-47b6-9cf3-fc4f8fcaf1f6): add ports as red wool
## next ~#

        # Build pallet: the palette is now a list of compounds containing a "Name".
        pallet = nbtlib.tag.List([
                Compound({"Name": nbtlib.tag.String("minecraft:air")}),
                Compound({"Name": nbtlib.tag.String("minecraft:white_wool")}),
                Compound({"Name": nbtlib.tag.String("minecraft:red_wool")}),
                Compound({"Name": nbtlib.tag.String("minecraft:redstone_wire")})
        ])

        # Build the overall schematic compound using the new format.
        schematic = Compound({
                "version": nbtlib.tag.Int(1),
                "size": nbtlib.tag.List([
                nbtlib.tag.Int(width),
                nbtlib.tag.Int(height),
                nbtlib.tag.Int(length)
                ]),
                "entities": nbtlib.tag.List([]),
                "palette": pallet,
                "blocks": nbtlib.tag.List(blocks)
        })

        # Create and save the NBT file.
        nbt_file = File(schematic)
        nbt_file.save(filename)
        print(f"Exported NBT schematic to {filename}")
import json
import random
import sys
import argparse
import pickle
from datetime import datetime
import os
from pathing import AStarSolver
import copy

verbose = False

## TODO @(dleiferives,4b111f97-d7e1-484f-8a5c-6d4680635be1): add rotations ~#

CELL_KINDS= {
    ## TODO @(dleiferives,7e67c6a6-6973-4872-ab9d-5e46375a07e9): add generationg
    ## of port cells automatically after parsing ports ~#
    "PORT_IN": {
        "x":1,
        "y":1,
        "z":2,
        "outputs": {
            "OUT": {
                "x": 0,
                "y": 0,
                "z": 1
            }
        }
    },
    "PORT_OUT": {
        "x":1,
        "y":1,
        "z":2,
        "inputs": {
            "IN": {
                "x": 0,
                "y": 0,
                "z": 1
            }
        }
    },
    "NAND": {
        "x":3,
        "y":3,
        "z":3,
        "inputs": {
            "A": {
                "x": 2,
                "y": 1,
                "z": 1
            },
            "B": {
                "x": 1,
                "y": 0,
                "z": 1
            }
        },
        "outputs": {
            "Y": {
                "x": 1,
                "y": 2,
                "z": 1
            }
        }
    },
    "NOR": {
        "x":3,
        "y":3,
        "z":3,
        "inputs": {
            "A": {
                "x": 2,
                "y": 1,
                "z": 1
            },
            "B": {
                "x": 1,
                "y": 0,
                "z": 1
            }
        },
        "outputs": {
            "Y": {
                "x": 1,
                "y": 2,
                "z": 1
            }
        }
    },
    "BUF": {
        "x":1,
        "y":1,
        "z":2,
        "inputs": {
            "A": {
                "x": 0,
                "y": 0,
                "z": 1
            }
        },
        "outputs": {
            "Y": {
                "x": 2,
                "y": 0,
                "z": 1
            }
        }
    },
    "NOT": {
        "x":3,
        "y":1,
        "z":2,
        "inputs": {
            "A": {
                "x": 0,
                "y": 0,
                "z": 1
            }
        },
        "outputs": {
            "Y": {
                "x": 2,
                "y": 0,
                "z": 1
            }
        }
    },
    "DFF": {
        "x":3,
        "y":3,
        "z":3,
        "inputs": {
            "D": {
                "x": 0,
                "y": 0,
                "z": 1
            },
            "C": {
                "x": 2,
                "y": 0,
                "z": 1
            }
        },
        "outputs": {
            "Q": {
                "x": 1,
                "y": 2,
                "z": 1
            }
        }
    },

}

# should make deep copy of layoutgenome first
# ie making new cells
# then do the mutations
class LayoutGenome:
    def __init__(self, cell_list, cell_lut, volume=[100, 100, 100],seed=420):
        self.cell_list = cell_list  # a list of Cell objects (with their positions)
        self.cell_lut = cell_lut    # a lookup for cells (by name)
        self.volume = volume
        self.fitness = None
        self.seed = seed
        if seed is None:
            random.seed()
        else:
            random.seed(seed);

    def mutate_movement(self, mutation_rate=0.1):
        """
        For each cell in the genome, slightly shift its position (if allowed)
        """
        layout = self.to_layout()
        for idx, cell in enumerate(self.cell_list):
            if random.random() < mutation_rate:
                # small delta chosen from -1, 0, or 1
                delta = [random.choice([-1, 0, 1]) for _ in range(3)]
                new_pos = cell.pos.copy()
                new_pos[0] += delta[0]
                new_pos[1] += delta[1]
                new_pos[2] += delta[2]

                # Ensure the new position does not violate volume bounds.
                if (
                    new_pos[0] < 0
                    or new_pos[1] < 0
                    or new_pos[2] < 0
                    or new_pos[0] + new_pos[3] > self.volume[0]
                    or new_pos[1] + new_pos[4] > self.volume[1]
                    or new_pos[2] + new_pos[5] > self.volume[2]
                ):
                    continue
                cell.pos = new_pos

    def random_cell_pos(self, cell):
        """
        Generate a completely new, random valid position for the given cell.
        Note: The effective cell dimensions are taken from CELL_KINDS with a 1-cell
        buffer on all sides.
        """
        if cell.kind not in CELL_KINDS:
            if verbose:
                print(f"Kind {cell.kind} not found in CELL_KINDS!")
            sys.exit(1)
        dims = CELL_KINDS[cell.kind]
        ext_w = dims["x"] + 6  # extra space for air gap
        ext_d = dims["y"] + 6
        ext_h = dims["z"] + 6
        x = random.randint(0, self.volume[0] - ext_w)
        y = random.randint(0, self.volume[1] - ext_d)
        z = random.randint(0, self.volume[2] - ext_h)
        # Return the inner cell position (offset by 1) plus the cell dimensions.
        return [x + 3, y + 3, z + 3, dims["x"], dims["y"], dims["z"]]

    def mutate_rand_pos(self, mutation_rate=0.05):
        """
        Pick a random cell and set its position completely at random.
        """
        cell = random.choice(self.cell_list)
        if random.random() < mutation_rate:
            new_pos = self.random_cell_pos(cell)
            if new_pos:
                cell.pos = new_pos

    @staticmethod
    def crossbreed(genome1, genome2):
        """
        Create a new genome by combining two parent genomes.
        (Cells are assumed to be in the same order in both genomes.)
        """
        if len(genome1.cell_list) != len(genome2.cell_list):
            if verbose:
                print("Genomes have different number of cells, cannot crossbreed")
            sys.exit(1)
        new_cell_list = []
        new_cell_lut = {}
        for cell1, cell2 in zip(genome1.cell_list, genome2.cell_list):
            # choose randomly from one of the parents
            chosen = cell1 if random.random() < 0.5 else cell2
            new_cell = copy.deepcopy(chosen)
            new_cell_list.append(new_cell)
            new_cell_lut[new_cell.name] = new_cell
        return LayoutGenome(new_cell_list, new_cell_lut, volume=genome1.volume)

    def to_layout(self):
        """
        Convert the genome into a full Layout instance. 'cells_config' and 'ports'
        are dictionaries parsed from JSON and used by Layout. If a cell is stored in
        the genome, a new Cell instance is created (with the genome’s cell position).
        """
        new_layout = Layout(cells={}, ports={}, volume=self.volume,seed=self.seed)
        new_layout.volume = self.volume
        new_layout.generated_cells = []
        new_layout.cells_lut = {}
        for cell in self.cell_list:
            new_cell = Cell(new_layout, cell.name, cell.kind,
                            ports=cell.ports, pos=cell.pos)
            new_layout.generated_cells.append(new_cell)
            new_layout.cells_lut[new_cell.name] = new_cell
        new_layout.rebuild_grid();
        new_layout.set_astar();
        return new_layout

    def compute_fitness(self):
        """
        Build a full layout from the genome and then generate wiring paths.
        If wiring fails (generate_paths returns -1), assign a heavy penalty.
        Otherwise, use the (negative) total wiring length as the fitness
        (lower wiring length is better).
        """
        res_length = -1
        max_len = -1
        try:
            layout_tmp = self.to_layout()
            if layout_tmp.overlap > 0:
                return -100 * layout_tmp.overlap
            res_length, max_len = layout_tmp.generate_paths()
            del layout_tmp
        finally:
            if res_length == -1:
                return -1e6
        # Fitness is defined so that a lower total wiring length gives a
        # higher fitness.
        return -res_length


class Layout:
    def __init__(self,cells={}, ports={}, volume=[50,50,50],seed=420):
        # cells is a dict of names -> things
        self.cells = cells
        self.ports = ports
        self.volume = volume
        self.wires = {}
        self.wires_lut = {}
        # "bit": [(NAME, MEMBER NAME)]
        temp = []
        for x in range(volume[0]*volume[1]*volume[2]):
            temp.append(None);
        self.grid = temp
        self.generated_cells = []
        self.gen_wires = []
        self.cells_lut = {}
        self.overlap = 0
        self.a_star = None;
        self.seed = seed
        if (seed is None):
            random.seed()
        else:
            random.seed(self.seed)



    def to_genome(self,seed=420):
        """
        Create and return a deep copy of this layout's genome.
        This copies the generated_cells and rebuilds the cell lookup
        dictionary, so that modifications to the genome do not affect
        the original layout.
        """
        # Create a deep copy of the generated cells list
        cells_copy = copy.deepcopy(self.generated_cells)

        # Rebuild the lookup dictionary using the copied cells.
        cell_lut_copy = {cell.name: cell for cell in cells_copy}
        if seed is not None:
            return LayoutGenome(cells_copy, cell_lut_copy, volume=self.volume,seed=seed)
        else:
            return LayoutGenome(cells_copy, cell_lut_copy, volume=self.volume,seed=self.seed)

    def deserialize_layout(filename):
        with open(filename, 'rb') as file:
            loaded_layout = pickle.load(file)
        return loaded_layout

    def serialize(self):
        current_utc = datetime.utcnow()
        date_string = current_utc.strftime("%Y%m%d_%H%M%S")

        filename = f"layout_{str(self.volume[1])}x{str(self.volume[1])}x{str(self.volume[1])}_{date_string}.pkl"

        with open(filename, 'wb') as file:
            pickle.dump(self, file)

        return filename

    def set_astar(self):
        self.a_star = AStarSolver(((0,0,0),(self.volume[0],self.volume[1],self.volume[1])),self.get_kind)

    def generate_start_layout(self):
        # self.serialize();
        self.a_star = AStarSolver(((0,0,0),(self.volume[0],self.volume[1],self.volume[1])),self.get_kind)
        # start with ports
        for port, body in self.ports.items():
            cell_name = port
            kind = "PORT_IN" if body['direction'] == 'input' else 'PORT_OUT'
            cell = Cell(self,port,kind)
            self.generated_cells.append(cell)
            self.cells_lut[cell_name] = cell
            if( not self.fill_volume(cell) ):
                if verbose:
                    print(f"Could not fill cell {cell.name} volume {cell.pos}")



        # then do cells
        for cell, body in self.cells.items():
            cell_name = cell
            cell = Cell(self,cell,body['type'])
            self.generated_cells.append(cell)
            self.cells_lut[cell_name] = cell
            if( not self.fill_volume(cell) ):
                if verbose:
                    print(f"Could not fill cell {cell.name} volume {cell.pos}")

    def rebuild_grid(self):
        overlap = 0
        self.grid = [None for e in range(self.volume[0]*self.volume[1]*self.volume[1])]
        for cell in self.generated_cells:
            overlap += self.fill_volume_compute_overlap(cell)
        self.overlap = overlap


    # used for fitness
    def generate_paths(self):
        """
        Generate output paths from the generated cells and process them.
        Only return after a fixed number of iterations (or if no failed paths).
        """
        output_paths = self._generate_output_paths()
        routed_paths = self._solve_generated_paths(output_paths)
        if routed_paths is None:
            return -1, -1

        path_len = 0
        num_paths = 0
        for p in routed_paths:
            if len(p) != 0:
                num_paths += 1
                path_len += len(p)
        return path_len, num_paths

    def _generate_output_paths(self):
        """
        Iterate over all generated cells to build the list of output paths.
        Each output path is a tuple: ((startx, starty, startz), (endx, endy, endz)).
        """
        output_paths = []
        for cell in self.generated_cells:
            kind = CELL_KINDS[cell.kind]
            if "outputs" not in kind:
                continue
            for out_name, out_rpos in kind["outputs"].items():
                startx = out_rpos["x"] + cell.pos[0]
                starty = out_rpos["y"] + cell.pos[1]
                startz = out_rpos["z"] + cell.pos[2]
                # Use the output name to get all the destination ports
                dests = cell.ports[out_name]
                for dest in dests:
                    dname = dest[0]
                    dport = dest[1]
                    dcell = self.cells_lut[dname]
                    dkind = CELL_KINDS[dcell.kind]
                    if dport not in dkind["inputs"]:
                        if verbose:
                            print(f"wire from output {cell.name} does not go to input at {dname}")
                    else:
                        end_pos = dkind["inputs"][dport]
                        endx = end_pos["x"] + dcell.pos[0]
                        endy = end_pos["y"] + dcell.pos[1]
                        endz = end_pos["z"] + dcell.pos[2]
                        output_paths.append(
                            ((startx, starty, startz), (endx, endy, endz))
                        )
        # print(f"{len(output_paths)} to solve")
        return output_paths

    def _solve_generated_paths(self, output_paths, large_log=False):
        """
        Attempt to solve paths in multiple iterations.
        In each iteration:
        - Save the current grid and gen_wires state.
        - Call _attempt_paths() which returns successful and failed paths along
            with the total length and the maximum length found in this attempt.
        - For every successful path that is longer than a minimal length, generate
            an extension path that will be attempted in the next iteration.
        - Combine the failed paths and extensions to form the set of paths for the
            next iteration.

        The loop terminates if no paths remain or after a maximum number of iterations.
        Returns a tuple of (overall_total_length, overall_max_path_length).
        """
        max_iterations = 5  # or any iteration limit you desire
        iteration = 0
        result_paths = []
        failed_paths = [0]
        saved_grid = [i for i in self.grid]

        base_saved_grid = [i for i in self.grid]
        base_saved_wires = [i for i in self.gen_wires]
        failed_tracker = {}
        input_paths = [ p for p in output_paths]
        fail_repeat_reset_threshold = 7
        while len(failed_paths) > 0:
            if iteration >= max_iterations:
                return None

            if not large_log:
                if verbose:
                    print(f"{iteration+1}",end='\r')
            else:
                if verbose:
                    print(f"--- Iteration {iteration+1}: "
                        f"{len(output_paths)} paths to attempt ---")

            # Save states for potential rollback or debugging.
            self.grid = [i for i in saved_grid]
            self.gen_wires = []
            self.a_star.get_kind_func = self.get_kind
            self.a_star.reset_caches()


            # Attempt to solve all given paths.
            successful_paths, failed_paths = (
                self._attempt_paths(output_paths)
            )

            if (len(failed_paths) > 0):
                if iteration == 0:
                    iteration += 1

                    self.grid = [i for i in saved_grid]
                    self.gen_wires = []
                    self.a_star.get_kind_func = self.get_kind
                    output_paths = []
                    for f in failed_paths:
                        output_paths.append(f)
                    for s in successful_paths:
                        output_paths.append((s[0],s[1]))


                self.grid = [i for i in saved_grid]
                self.gen_wires = []
                self.a_star.get_kind_func = self.get_kind

                # For every successful path, try to extend it a little further.
                new_extensions = []
                new_results = {}
                for path in successful_paths:
                    # For example, if the solved path is long, take a segment extension.
                    if path[0] not in new_results:
                        new_results[path[0]] = { 'paths':[], 'path': None, 'new_start': None, 'new_goal': None }
                    new_results[path[0]]['paths'].append(path)
                    new_results[path[0]]['path'] = path[:2]
                    new_results[path[0]]['new_start'] = path[2]
                    new_results[path[0]]['new_goal'] = path[-1]

                for entry in new_results.values():
                    result_paths.append(entry['path'])
                    self.fill_path(entry['path'],2)
                    for epath in entry['paths']:
                        # Using the third node onward as an "extension" to solve further.
                        new_extensions.append((entry['path'][0], epath[-1]))


                # Combine failed paths and extensions for the next iteration.
                output_paths = []
                continue_me = False
                for p in failed_paths:
                    output_paths.append(p)
                    if p not in failed_tracker:
                        failed_tracker[p] = 1
                    else:
                        failed_tracker[p] += 1

                    if failed_tracker[p] > fail_repeat_reset_threshold:
                        # we are going to reset
                        self.grid = [i for i in base_saved_grid]
                        saved_grid = [i for i in base_saved_grid]
                        self.gen_wires = []
                        failed_paths = [0]
                        failed_sort = sorted(failed_tracker.items, reverse=True)
                        output_paths = []
                        for s in failed_sort:
                            if s[0] in input_paths:
                                output_paths.append(s[0])
                        for s in input_paths:
                            if s not in output_paths:
                                output_paths.append(s)
                        failed_tracker = {}
                        continue_me = True
                        break

                if continue_me:
                    continue

                for p in new_extensions:
                    output_paths.append(p)
                saved_grid = [i for i in self.grid]
            else:
                for p in successful_paths:
                    result_paths.append(p)
                    pass

            iteration += 1
        self.gen_wires = [w for w in result_paths]
        return result_paths


    def _attempt_paths(self, paths, limit=100000,verbose=False):
        """
        Attempt to solve a list of paths using A* with a given search limit.
        For each path:
        - Try the 'fast' instance of A* (using limit).
        - If that fails, try the reverse direction.
        - If still unresolved, try with no limit (limit=-1).
        - Add successfully solved paths to the list and fill the path on the grid.
        - For paths that remain unsolved, add them to the failed_paths list.

        Returns:
        successful_paths (list of solved paths),
        failed_paths (list of unresolved paths),
        total_length (cumulative length of all solved paths),
        max_length (length of the longest solved path).
        """
        successful_paths = []
        failed_paths = []

        for idx, path in enumerate(paths):
            if verbose:
                print(f"Attempting path {idx+1}/{len(paths)}: "
                    f"{path[0]} -> {path[1]}")
            solved = None

            try:
                solved = self.a_star.solve(path[0], path[1], limit)
                if solved is False:
                    solved = self.a_star.solve(path[1], path[0], limit)
                    if isinstance(solved, list):
                        solved.reverse()
            except Exception as e:
                failed_paths.append(path)
                if verbose:
                    print(f"Fast attempt {limit} searches: {e}")
            else:

                if solved and solved is not False:
                    successful_paths.append(solved)
                    self.gen_wires.append(solved)
                    self.fill_path(solved, -1)
                else:
                    # Try a backup attempt with no limit.
                    try:
                        solved = self.a_star.solve(path[0], path[1], -1)
                    except Exception as e:
                        if verbose:
                            print(f"Full attempt failed: {e}")
                        solved = False

                    if solved and solved is not False:
                        successful_paths.append(solved)
                        self.gen_wires.append(solved)
                        self.fill_path(solved, -1)
                    else:
                        failed_paths.append(path)
                        if verbose:
                            print(f"Path {idx+1} failed all attempts.")

        return successful_paths, failed_paths


    def parse_ports(self,ports):
        if ports is None:
            return
        for port, body in ports.items():
            self.ports[port] = body
            if port not in self.wires:
                self.wires[port] = { 'connections': {}, 'bits': []}
            direction = 'OUT' if body['direction'] == 'input' else 'IN'
            self.wires[port]['connections'][direction] = body['bits'][0]
            self.wires[port]['bits'].append(body['bits'][0])
            if str(body['bits'][0]) not in self.wires_lut:
                self.wires_lut[str(body['bits'][0])] = []
            self.wires_lut[str(body['bits'][0])].append((port, direction));

    def parse_cells(self,cells):
        if cells is None:
            return
        for cell, body in cells.items():
            self.cells[cell] = body
            if cell not in self.wires:
                self.wires[cell] = {'connections': {}, 'bits': []}
            for con_name, con_val in body['connections'].items():
                self.wires[cell]['connections'][con_name] = con_val[0];
                self.wires[cell]['bits'].append(con_val[0])
                if str(con_val[0]) not in self.wires_lut:
                    self.wires_lut[str(con_val[0])] = []
                self.wires_lut[str(con_val[0])].append((cell, con_name));


    def parse_json(self,contents):
        if "modules" not in contents:
            exit("No modules");
        contents = contents['modules']
        ## TODO @(dleiferives,823a4f84-53ff-4602-8ff9-f93688e68854): make this not
        ## just be the first entry ~#
        for key in contents.keys():
            contents = contents[key]
            break
        self.parse_ports(contents['ports']);
        self.parse_cells(contents['cells'])

    def get_index(self,x,y,z):
        return z*self.volume[0]*self.volume[1] + y*self.volume[0] + x;

    def fill_path(self, path, n,my_grid=True):
        if n == -1:
            n = 1000000
        path_id = (path[0], path[-1]), path
        _, *r_path, _2 = path
        ctr = 0
        for step in r_path:
            if (ctr > n):
                break
            x = step[0]
            y = step[1]
            z = step[2]
            ctr += 1
            for d in [[0, 0, 0],
                      [0, 0, 1],
                      [0, 0, -1],
                      [1, 0, 0],
                      [-1, 0, 0],
                      [0, 1, 0],
                      [0, -1, 0]
                      ]:
                dx, dy, dz = d
                filled = self.get_kind(x+dx,y+dx,z+dz)
                if isinstance(filled, tuple):
                    fp, fstate, _, fpp = filled
                    if fstate == False or fstate == 'top':
                        if d == [0,0,0]:
                            if verbose:
                                print(f"tried to place wire in illegal position")

                    elif fstate == 'top':
                        if dz == -1:
                            tpid = path_id[0], False, (x,y,z), path_id[1]
                            self.grid[self.get_index(x+dx,y+dy,z+dz)] = tpid

                        if d == [0,0,0]:
                            tpid = path_id[0], True, (x,y,z), path_id[1]
                            self.grid[self.get_index(x+dx,y+dy,z+dz)] = tpid
                    else:
                        if d == [0,0,0] and fstate != True:
                            tpid = path_id[0], True, (x,y,z), path_id[1]
                            self.grid[self.get_index(x+dx,y+dy,z+dz)] = tpid


                    # if(filled != path_id):
                        # print("tried to overlay two paths!")
                    continue
                elif filled is None:
                    tpid = path_id
                    if (d == [0,0,0]):
                        tpid = path_id[0], True, (x,y,z), path_id[1]
                    elif dz == -1:
                        tpid = path_id[0], False, (x,y,z), path_id[1]
                    elif dz == 0:
                        tpid = path_id[0], None, (x,y,z), path_id[1]
                    elif dz == 1:
                        tpid = path_id[0], 'top', (x,y,z), path_id[1]
                    else:
                        if verbose:
                            print("impossible state reached in parsing")
                        sys.exit("aa");
                    self.grid[self.get_index(x+dx,y+dy,z+dz)] = tpid

                else:
                    pass
        if my_grid:
            return None
        else:
            return grid
                    # print(f"path trying to place at {x} {y} {z} object {self.grid[self.get_index(x,y,z)]} present")
    def fill_volume_compute_overlap(self, cell):
        x = cell.pos[0]
        y = cell.pos[1]
        z = cell.pos[2]
        width = cell.pos[3]
        depth = cell.pos[4]
        height = cell.pos[5]
        error_counter = 0

        if(width + x >= self.volume[0]):
            diff = width + x - self.volume[0]
            error_counter += depth*height*diff
            width = width - diff -1 if diff -1 > 0 else 0

        if(depth + y >= self.volume[1]):
            diff = depth + y - self.volume[1]
            error_counter += width*height*diff
            depth= depth - diff -1 if diff -1 > 0 else 0

        if(height + z >= self.volume[2]):
            diff = height + z - self.volume[2]
            error_counter += width*depth*diff
            height = height - diff -1 if diff -1 > 0 else 0

        for dx in range(width):
            for dy in range(depth):
                for dz in range(height):
                    idx = self.get_index(dx+x,dy+y,dz+z);
                    if self.grid[idx] != None:
                        error_counter += 1

        for dx in range(width):
            for dy in range(depth):
                for dz in range(height):
                    idx = self.get_index(dx+x,dy+y,dz+z);
                    self.grid[idx] = str(cell.name)

        return error_counter


    def fill_volume(self, cell):
        x = cell.pos[0]
        y = cell.pos[1]
        z = cell.pos[2]
        width = cell.pos[3]
        depth = cell.pos[4]
        height = cell.pos[5]
        error_counter = 0
        if(width + x >= self.volume[0]):
            error_counter += 1000
            return False

        if(depth + y >= self.volume[1]):
            return False

        if(height + z >= self.volume[2]):
            return False

        for dx in range(width):
            for dy in range(depth):
                for dz in range(height):
                    idx = self.get_index(dx+x,dy+y,dz+z);
                    if self.grid[idx] != None:
                        return False

        for dx in range(width):
            for dy in range(depth):
                for dz in range(height):
                    idx = self.get_index(dx+x,dy+y,dz+z);
                    self.grid[idx] = str(cell.name)
                    if self.grid[idx] == None:
                        self.grid[idx] = True

        return True

    def get_kind(self, x, y, z):
        if(1 + x >= self.volume[0]):
            return False

        if(1 + y >= self.volume[1]):
            return False

        if(1 + z >= self.volume[2]):
            return False

        idx = self.get_index(x,y,z);
        if self.grid[idx] != None:
            if isinstance(self.grid[idx], tuple):
                return self.grid[idx]
            else:
                return False
        else:
            return None


    def volume_empty(self, width, height, depth, x, y, z):
        #/ TODO @(dleiferives,2568b396-654f-493a-ae21-e6215aee77a3): optimize this ~#
        if(width + x >= self.volume[0]):
            return False

        if(depth + y >= self.volume[1]):
            return False

        if(height + z >= self.volume[2]):
            return False

        for dx in range(width):
            for dy in range(depth):
                for dz in range(height):
                    idx = self.get_index(dx+x,dy+y,dz+z);
                    if self.grid[idx] != None:
                        return False

        return True


    def new_cell_pos(self,kind,trials=1000,every_pos=False):
        if kind not in CELL_KINDS:
            if verbose:
                print(f"kind {kind} not found in kinds {CELL_KINDS.keys()}");
            sys.exit(1)

        kind = CELL_KINDS[kind];
        # oversize the volume so there is air gap
        width = kind['x'] + 6;
        height = kind['z'] + 6;
        depth = kind['y'] + 6;

        for _ in range(trials):
            # random position
            rpos_x = random.randint(0, self.volume[0] - width)
            rpos_y = random.randint(0, self.volume[1] - height)
            rpos_z = random.randint(0, self.volume[2] - depth)
            if (self.volume_empty(width,height,depth,rpos_x,rpos_y,rpos_z) == True):
                # center cell and reduce vol
                return [rpos_x+3, rpos_y+3, rpos_z+3, width-6, depth-6, height-6]

        # no pos found in n random trials. checking every position
        if not every_pos:
            return None

        for x in range(self.volume[0]):
            for y in range(self.volume[1]):
                for z in range(self.volume[2]):
                    if (self.volume_empty(width,height,depth,x,y,z) == True):
                        # center cell and reduce vol
                        return [x+3, y+3, z+3, width-6, depth-6, height-6]

        return None

    def get_cell_ports(self, cell_name):
        if cell_name not in self.wires:
            sys.exit("cell name not found in wires!")

        result = {}
        wire = self.wires[cell_name]
        for con_name, bit in wire['connections'].items():
            other_bit = []
            lut = self.wires_lut[str(bit)]
            for entry in lut:
                if entry[0] != cell_name:
                    other_bit.append(entry)
            result[con_name] = other_bit

        return result



class Cell:
    # Layout is layout parent
    # kind is one of the cell cinds
    # name is the name from the json eg "$abc$129$auto$blifparse.cc:396:parse_blif$137"
    # ports is {
    #   "<port name ie A>": [(<cell connecting to name>, <cell connecting to port name connecting to>)]
    # }
    # pos is [x, y, z, width, depth, height]
    def __init__(self,layout,name,kind,ports=None,pos=None):
        self.layout = layout
        self.kind = kind;
        self.name = name
        if pos == None:
            pos = layout.new_cell_pos(kind)
        if pos == None:
            if verbose:
                print(f"Could not find position for cell {kind},{id},{pos},{ports},{connections}")
            sys.exit(1)
        self.pos = pos

        if ports == None:
            ports = layout.get_cell_ports(name)
        if ports == None:
            ports = {}
            if verbose:
                print(f"WARNING: no ports for cell {name}")
        self.ports = ports
import heapq
from typing import Tuple, List, Dict, Optional, Callable, Any


class OutOfBoundsError(Exception):
    pass


class NoPathFoundError(Exception):
    pass


class AStarSolver:
    def __init__(
        self,
        bounds: Tuple[Tuple[int, int, int], Tuple[int, int, int]],
        get_kind: Callable[[int, int, int], Any],
    ):
        """
        Initialize the solver with a bounding volume and a function to
        check the type of a cell.

        Parameters:
          bounds: A tuple of ((min_x, min_y, min_z), (max_x, max_y, max_z)).
          get_kind: A callable that, given (x, y, z), returns:
                    - None if the cell is empty (air).
                    - "full" if the cell is blocked.
                    - A list of positions representing an alternate integrated
                      path. In that case, the list should begin (or end) with the
                      current cell if this path is to be used as an entry point.
        """
        self.bounds = bounds
        self.get_kind_func = get_kind
        self.lut = {}
        self.invalid_path_lut = {}
        self.invalid_lut = {}
        self.clearance_lut = {}
        self.kind_lut = {}

        (self.min_x, self.min_y, self.min_z), (
            self.max_x,
            self.max_y,
            self.max_z,
        ) = bounds

        # Allowed moves:
        # Horizontal moves (same z-level)
        self.horizontal_moves = [
            (1, 0, 0),
            (-1, 0, 0),
            (0, 1, 0),
            (0, -1, 0),
        ]
        # Staircase moves upward (requires a horizontal component)
        self.staircase_moves_up = [
            (1, 0, 1),
            (-1, 0, 1),
            (0, 1, 1),
            (0, -1, 1),
        ]
        # Staircase moves downward
        self.staircase_moves_down = [
            (1, 0, -1),
            (-1, 0, -1),
            (0, 1, -1),
            (0, -1, -1),
        ]
        self.all_moves = (
            self.horizontal_moves + self.staircase_moves_up + self.staircase_moves_down
        )

    def get_kind(self, pos):
        if pos in self.kind_lut:
            return self.kind_lut[pos]
        kind = self.get_kind_func(*pos)
        self.kind_lut[pos] = kind
        return kind


    def in_bounds(self, pos: Tuple[int, int, int]) -> bool:
        """Check if the given position is within bounds."""
        x, y, z = pos
        return (
            self.min_x <= x <= self.max_x
            and self.min_y <= y <= self.max_y
            and self.min_z <= z <= self.max_z
        )

    def heuristic(self, a: Tuple[int, int, int], b: Tuple[int, int, int]) -> int:
        """Manhattan distance heuristic."""
        return abs(a[0] - b[0]) + abs(a[1] - b[1]) + abs(a[2] - b[2])

    def _has_clearance(
        self, pos: Tuple[int, int, int], start: Tuple[int, int, int],
            goal: Tuple[int, int, int], ignore=[]
    ) -> bool:
        """
        Check if the given cell at pos satisfies the clearance requirement.

        Clearance now means that every neighboring cell (including
        diagonals in all three dimensions, i.e. all 26 adjacent cells)
        must be air (get_kind returns None), unless that neighbor is the
        start or goal. This ensures the wiring cell is completely isolated,
        except in the direction where it connects to an endpoint.
        """
        if pos in self.clearance_lut:
            return self.clearance_lut[pos]
        x, y, z = pos


        for d in [[0, 0, 1],
                    [0, 0, -1],
                    [1, 0, 0],
                    [-1, 0, 0],
                    [0, 1, 0],
                    [0, -1, 0]
                    ]:
            dx, dy, dz = d
            neighbor = (x + dx, y + dy, z + dz)
            if(neighbor in ignore):
                continue
            # If the neighbor is an endpoint, allow any content.
            if neighbor == start or neighbor == goal:
                ignore.append(neighbor)
        for d in [[0, 0, 1],
                    [0, 0, -1],
                    [1, 0, 0],
                    [-1, 0, 0],
                    [0, 1, 0],
                    [0, -1, 0]
                    ]:
            dx, dy, dz = d
            neighbor = (x + dx, y + dy, z + dz)
            kind = self.get_kind(neighbor)
            if(neighbor in ignore):
                continue
            if dx == 0 and dy == 0 and dz == 0:
                continue  # Skip the cell itself.
            if not self.in_bounds(neighbor):
                # if(start == (9, 20, 34)):
                #     print(f"failed {neighbor} bounds")
                self.clearance_lut[pos] = False
                return False
            # The neighbor must be air.
            if kind == False:
                self.clearance_lut[pos] = False
                return False
            if kind is None:
                flag = True
                if len(ignore) == 0:
                    for d2 in [[0,0,0],
                            [0, 0, 1],
                                [0, 0, -1],
                                [1, 0, 0],
                                [-1, 0, 0],
                                [0, 1, 0],
                                [0, -1, 0]
                                ]:
                        dx2, dy2, dz2 = d2
                        n2 = (neighbor[0] + dx2, neighbor[1] + dy2, neighbor[2] + dz2)
                        if n2 in ignore:
                            continue
                        k2 = self.get_kind(n2)
                        if n2 == start or n2 == goal:
                            flag = True
                            break
                        if k2 == False:
                            flag = False
                        if k2 is None:
                            continue
                        else:
                            p2, s2, *_ = k2
                            if p2[0] == start or p2[0] == goal:
                                continue
                            if p2[1] == goal or p2[1] == start:
                                continue
                            flag = False

                    if flag == True:
                        continue
                    else:
                        self.clearance_lut[pos] = False
                        return False
                else:
                    continue
            if not (isinstance(kind, tuple)):
                self.clearance_lut[pos] = False
                return False
            else:
                pid, state, *_ = kind
                if state is None and dz == -1:
                    continue
                if pid[0] == start or pid[0] == goal:
                    continue
                if pid[1] == goal or pid[1] == start:
                    continue
                # if(start == (9, 20, 34)):
                #     print(f"failed {neighbor} path")
                self.clearance_lut[pos] = False
                return False
        self.clearance_lut[pos] = True
        return True

    def reset_path_caches(self):
        self.clearance_lut = {}
        self.kind_lut = {}
        self.invalid_path_lut = {}

    def reset_caches(self):
        self.invalid_lut = {}
        self.invalid_path_lut = {}
        self.clearance_lut = {}
        self.kind_lut = {}

    def solve(
        self, start: Tuple[int, int, int], goal: Tuple[int, int, int],max_iterations
    ) -> List[Tuple[int, int, int]]:
        """
        Perform A* search from start to goal.

        Requirements:
          - For any cell other than start or goal, get_kind must return None (air)
            and the cell must satisfy clearance conditions.
          - If get_kind returns a path for a cell (and that path begins or ends with
            start or goal), then that alternate (integrated) path is allowed.
          - The final solution is the complete route from the original start to the
            goal, including any jumps onto alternate integrated paths.

        Raises:
          OutOfBoundsError: if start or goal are out of bounds.
          NoPathFoundError: if no valid path exists.
        """
        self.reset_caches()
        if max_iterations == -1:
            iterations = 100000000000000
        else:
            iterations = max_iterations
        # print(iterations)
        if not self.in_bounds(start):
            raise OutOfBoundsError("Start position is out of bounds")
        if not self.in_bounds(goal):
            raise OutOfBoundsError("Goal position is out of bounds")

        # A* search initialization.
        open_set = []
        heapq.heappush(open_set, (self.heuristic(start, goal), 0, start))
        came_from: Dict[Tuple[int, int, int],
                        Optional[Tuple[int, int, int]]] = {start: None}
        cost_so_far: Dict[Tuple[int, int, int], int] = {start: 0}

        it_counter = 0
        while open_set:
            if(it_counter > iterations):
                return False
            it_counter += 1
            _, current_cost, current = heapq.heappop(open_set)

            if current == goal:
                # Reconstruct path by walking back from goal.
                path = []
                while current is not None:
                    path.append(current)
                    current = came_from[current]
                path.reverse()
                return path

            for dx, dy, dz in self.all_moves:
                if(it_counter > iterations):
                    return False
                it_counter += 1
                extra_paths =[]
                neighbor = (
                    current[0] + dx,
                    current[1] + dy,
                    current[2] + dz,
                )

                if neighbor in self.invalid_lut:
                    continue
                if neighbor in self.invalid_path_lut:
                    continue

                if not self.in_bounds(neighbor):
                    self.invalid_lut[neighbor] = True
                    continue

                # For endpoints, clearances are not enforced.
                if neighbor != start and neighbor != goal:
                    kind = self.get_kind(neighbor)
                    if kind == False:
                        continue

                    if kind is None:
                        # For wiring cells, the cell must be air and have full clearance.
                        if not self._has_clearance(neighbor, start, goal):
                            self.invalid_lut[neighbor] = True
                            continue
                        extra_paths.append((neighbor, 0))
                    else:
                        # If get_kind returns an integrated path, then only allow it if it
                        # begins or ends with the start or goal.
                        if not (isinstance(kind, tuple) and kind):
                            continue
                        npid, nstate, nneb, npath = kind
                        nstart, ngoal = npid
                        if ngoal == goal:
                            ncst = 0
                            if nstate == True:
                            # we have found our path to the goal
                                if nneb not in npath:
                                    self.invalid_path_lut[nneb] = True
                                    continue
                            elif nstate == False or nstate == 'top':
                                self.invalid_path_lut[nneb] = True
                                continue

                            else:
                                # we are one away and just have to produce
                                tdx, tdy, tdz = nneb
                                if nneb not in npath:
                                    self.invalid_path_lut[nneb] = True
                                    continue
                                else:
                                    ncst = 1;
                                    extra_paths.append((neighbor,0))

                            nindex = npath.index(nneb)
                            nnpath = npath[nindex:]
                            for nix, nstep in enumerate(nnpath):
                                extra_paths.append((nstep,nix + ncst))

                        elif nstart == start:
                            if nstate == True or nstate is None:
                                extra_paths.append((neighbor,0))

                    for alt_pos, extra_cost in extra_paths:
                        new_cost = cost_so_far[current] + 1 + extra_cost
                        if alt_pos not in cost_so_far or new_cost < cost_so_far[alt_pos]:
                            cost_so_far[alt_pos] = new_cost
                            priority = new_cost + self.heuristic(alt_pos, goal)
                            heapq.heappush(open_set, (priority, new_cost, alt_pos))
                            came_from[alt_pos] = current
                else:
                    new_cost = cost_so_far[current] + 1
                    if neighbor not in cost_so_far or new_cost < cost_so_far[neighbor]:
                        cost_so_far[neighbor] = new_cost
                        priority = new_cost + self.heuristic(neighbor, goal)
                        heapq.heappush(open_set, (priority, new_cost, neighbor))
                        came_from[neighbor] = current

        raise NoPathFoundError(
            f"No valid path found from start to goal in current state. {start}->{goal}"
        )


# Example usage:
if __name__ == "__main__":
    # Example get_kind implementation.
    # This dummy function returns:
    #   - None if the cell is empty (air).
    #   - "full" if the cell is blocked.
    #   - An integrated path (list of positions) if one is present at a cell.
    #
    # For demonstration, suppose cell (2, 2, 0) has an integrated redstone wire path:
    # It returns a path from (2, 2, 0) to (2, 3, 0) to (2, 4, 0).
    def get_kind(x: int, y: int, z: int):
        if (x, y, z) == (2, 2, 0):
            return [(2, 2, 0), (2, 3, 0), (2, 4, 0)]
        # Block another cell for demonstration.
        if (x, y, z) == (3, 3, 0):
            return "full"
        return None

    # Define a bounding volume: ((min_x, min_y, min_z), (max_x, max_y, max_z)).
    bounds = ((0, 0, 0), (10, 10, 10))
    solver = AStarSolver(bounds, get_kind)

    start_position = (0, 0, 0)
    goal_position = (5, 5, 0)

    try:
        path = solver.solve(start_position, goal_position)
        print("Path found:")
        for pos in path:
            print(pos)
    except (OutOfBoundsError, NoPathFoundError) as err:
        print(f"Error: {err}")
